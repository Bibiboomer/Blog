更新于2019年2月16日
## 执行上下文
> 最近看了一篇前辈的文章，文章对于基础知识和细节的深入，收获颇多，感觉对于理解事件循环的机制很有帮助。阅读了这篇[深入执行上下文栈](https://github.com/mqyqingfeng/Blog/issues/4) 以及一些评论，总结出以下内容以及疑惑点

总结：
- js引擎在**执行一段代码时**，（会进行准备工作：例如变量或函数提升）——即创建执行上下文；
- js引擎创建了执行上下文栈来管理创建的执行上下文(execution context)
- 执行上下文栈负责创建执行上下文

疑问：
- 作用域与执行上下文是否是同一概念
- 执行上下文是否可以理解为js引擎的预编译阶段，包括执行阶段嘛
- 函数调用栈是否可以理解为上下文执行栈

梳理：
- 作用域和变量对象都是一种规定数据存储和访问的机制，变量对象将抽象的作用域概念实体化为对象

## 变量对象
> 跟着作者的思路，后续阅读[深入变量对象](https://github.com/mqyqingfeng/Blog/issues/5)

### 1、每个执行上下文有三个重要的属性
- 变量对象（* Variable object，VO）---本文研究重点
- 作用域链
- this

### 2、执行上下文区分两种情况讨论
- 全局执行上下文
- 函数执行上下文

#### 2.1全局执行上下文中的变量对象就是全局对象
```
<!-- 全局对象可以通过this访问，在客户端js全局对象就是window对象 -->
var a = 1;
console.log(window.a);
this.window.b = 2;
console.log(this.b);
```
#### 2.2函数执行上下文以活动对象来表示变量对象
> 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

#### 2.3 活动对象的总结
- 活动对象是在进入函数上下文时被创建-即执行函数时才存在AO
- 活动对象和变量对象为同一个对象，区别:是否能访问，位于执行上下文的不同周期
- AO在*进入执行阶段**被激活，激活前为OA，传入了OA没有的parameters和arguments对象

### 3、执行上下文的两个阶段
- 进入执行上下文
- 执行代码

#### 3.1进入执行上下文
此时创建变量对象，变量对象
创建过程：
1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值(全局环境下没有这步)。
2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。**如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。** 
3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。**如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。**(上面的例子就属于这种情况，foo函数名与变量foo同名)<br>

变量对象包括：
1. 函数的所有形参 (如果是函数上下文)
    - 由名称和对应值组成的一个变量对象的属性被创建
    - 没有实参，属性值设为 undefined
2. 函数声明
    - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
    - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
    - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
    - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

#### 3.1.1
对于变量对象的创建过程，在词法分析阶段有另外一种思路，
由于词法分析阶段：
1. 分析形参：接收形参到挂载到AO，接收实参赋值，如果没有传实参，值为undefined
2. 分析变量声明（var）：如果AO上已存在，不做修改（var 声明的变量和参数本质上都是私有变量），如果AO上不存在，挂载到AO,值undefined。
3. 分析函数声明：挂载函数名到AO，**并赋值函数体**， 如果AO上已存在，覆盖。
4. 词法分析顺序：形参->var声明->函数声明（包括赋值）
5. 执行阶段：进行var声明的变量的赋值
>函数声明，在词法分析阶段，函数名挂载到AO上时，就在这个阶段立马赋值。
var 声明的变量，词法解析阶段，只负责挂载该变量到AO上，值为undefined，赋值在执行阶段进行。
也就是说在执行阶段赋值的，只剩下var声明的变量。
即使是使用var声明的函数表达式这种情况，在AO上值也为undefined。
```
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};
  b = 3;
}
foo(1);
```
执行foo函数时，创建了执行上下文。在进入foo函数的执行上下文时，对应的活动对象AO
```
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```
#### 3.2执行阶段
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
依旧惨遭上个例子,执行结束后的活动对象为
AO={
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}

### D总结
到这里变量对象的创建过程总结如下:<br>
1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值


参考资料：https://github.com/mqyqingfeng/Blog/issues/4
